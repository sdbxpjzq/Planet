## epoll

1. fd 不是保存在用户空间，而是保存在内核空间的**事件表**上，所以，没有额外拷贝数据的开销；
2. 每个 fd 会对应到相应的事件上，当事件发生时通过回调函数通知应用程序，所以，没有遍历全量 fd 的开销；

3. 没有 fd 数量的最大限制。



先用 epoll_ctl 维护等待队列，再调用 epoll_wait 阻塞进程



```
epoll_create场景
大学开学第一周，你作为班长需要帮全班同学领取相关物品，你在学生处告诉工作人员，我是xx学院xx专业xx班的班长，这时工作人员确定你的身份并且给了你凭证，后面办的事情都需要用到(也就是调用epoll_create向内核申请了epfd结构，内核返回了epfd句柄给你使用)；

epoll_ctl场景
你拿着凭证在办事大厅开始办事，分拣办公室工作人员说班长你把所有需要办理事情的同学的学生册和需要办理的事情都记录下来吧，于是班长开始在每个学生手册单独写对应需要办的事情：李明需要开实验室权限、孙大熊需要办游泳卡......就这样班长一股脑写完并交给了工作人员(也就是告诉内核哪些fd需要做哪些操作)；

epoll_wait场景
你拿着凭证在领取办公室门前等着，这时候广播喊xx班长你们班孙大熊的游泳卡办好了速来领取、李明实验室权限卡办好了速来取....还有同学的事情没办好，所以班长只能继续(也就是调用epoll_wait等待内核反馈的可读写事件发生并处理)；
```



epoll 通知应用程序的方式有两种：`水平触发`和`边缘触发`

当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序时：

1.如果是`水平触发`(默认)，应用程序这次可以不处理，下次调用 epoll_wait 时，还会收到该通知；

只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作



2.如果是`边缘触发`，应用程序这次必须处理，因为下次调用 epoll_wait 时，不会再收到该通知。



https://mp.weixin.qq.com/s/6VRkbkGHYsEAPvTSd3KXoQ

