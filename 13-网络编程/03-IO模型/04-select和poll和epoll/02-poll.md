## poll

poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构，其他的都差不多。



传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。



**缺点：**

1、将多个文件描述符（fd）放入一个`链表`, 每次调用 epoll 时，需要将链表从用户空间拷贝到内核空间，当链表很大时会非常耗时

2、在内核中的每次调度，都会遍历链表中的所有 fd，不必要的耗时





**优点：**

- 解决了文件描述符大小的限制，poll文件描述是没有大小限制的, 原因是它是基于链表来存储的
- 解决了fd_set 不可重用的问题



 **执行流程**

第一步：将用户态rset拷贝到内核态中，如下图所示，

第二步：遍历文件描述符，判断是否数据可读，

第三步：如没有数据，将在内核中阻塞。

第四步：如有数据，1.将pollfd.revents置位(有数据)，2.poll 返回

