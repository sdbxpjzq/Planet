## 为什么需要 TIME_WAIT 状态？

主动发起关闭连接的一方，才会有 `TIME-WAIT` 状态。

需要 TIME-WAIT 状态，主要是两个原因：

- 防止具有相同「四元组」的「旧」数据包被收到；
  - 经过 `2MSL` 这个时间，**足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。**
-  等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。







## 为什么 TIME_WAIT 等待的时间是 2MSL

`MSL` 是 Maximum Segment Lifetime，**报文最大生存时间**，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 `TTL` 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。



TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是：

网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以**一来一回需要等待 2 倍的时间**。



在 Linux 系统里 `2MSL` 默认是 `60` 秒，那么一个 `MSL` 也就是 `30` 秒。**Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒**。



## TIME_WAIT 过多有什么危害

过多的 TIME-WAIT 状态主要的危害有两种：

- 第一是内存资源占用；
- 第二`端口耗尽`，一个 TCP 连接至少消耗一个本地端口；



可以通过修改以下配置进行服务器调优：

1. net.ipv4.tcp_tw_reuse 和 tcp_timestamps

```
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_timestamps = 1
```

- 开启后，作为客户端时新连接可以使用仍然处于 `TIME_WAIT`状态的端口
- 由于引入了时间戳，我们在前面提到的 `2MSL` 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。

> 温馨提醒：`net.ipv4.tcp_tw_reuse`要慎用，因为使用了它就必然要打开时间戳的支持 `net.ipv4.tcp_timestamps`，**当客户端与服务端主机时间不同步时，客户端的发送的消息会被直接拒绝掉**。



2. net.ipv4.tcp_max_tw_buckets

   这个值默认为 18000，当系统中处于 TIME_WAIT 的连接**一旦超过这个值时，系统就会将所有的 TIME_WAIT 连接状态重置。**

   这个方法过于暴力，而且治标不治本，带来的问题远比解决的问题多，不推荐使用。

3. *程序中使用 SO_LINGER*

   我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。

   





