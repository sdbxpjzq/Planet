**在 Redis 6.0 中新增了多线程的功能来提高 I/O 的读写性能，他的主要实现思路是将主线程的 IO 读写任务拆分给一组独立的线程去执行，这样就可以使多个 socket 的读写可以并行化了，但 Redis 的命令依旧是由主线程串行执行的**。



需要注意的是 **Redis 6.0 默认是禁用多线程的**，可以通过修改 Redis 的配置文件 redis.conf 中的 `io-threads-do-reads` 等于 `true` 来开启多线程，完整配置为 `io-threads-do-reads true`，除此之外我们还需要设置线程的数量才能正确的开启多线程的功能，同样是修改 Redis 的配置，例如设置 `io-threads 4` 表示开启 4 个线程。

> 小贴士：关于线程数的设置，官方的建议是如果为 4 核的 CPU，建议线程数设置为 2 或 3，如果为 8 核 CPU 建议线程数设置为 6，线程数一定要小于机器核数，线程数并不是越大越好。

Redis 虽然依靠自己的：基于内存操作、数据结构简单、多路复用和非阻塞 I/O、避免了不必要的线程上下文切换等特性，在单线程的环境下依然很快；但对于大数据的 key 删除还是卡的飞起，因此**在 Redis 4.0 引入了多线程：unlink key/flushall async 等命令，主要用于 Redis 数据的删除，而在 Redis 6.0 中引入了 I/O 多线程的读写，这样就可以更加高效的处理更多的任务**了





Redis 只是将 I/O 读写变成了多线程，而命令的执行依旧是由主线程串行执行的，因此在多线程下操作 Redis 不会出现线程安全的问题。