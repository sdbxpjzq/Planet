**1. 基于数据库表**

最简单的方式可能就是直接创建一张锁表，当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录。`给某字段添加唯一性约束`，如果有多个请求同时提交到数据库的话，**数据库会保证只有一个操作可以成功**，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。

会引入数据库单点、无失效时间、不阻塞、不可重入等问题。

**2. 基于数据库排他锁**

如果使用的是MySql的InnoDB引擎，在查询语句后面增加`for update`，数据库会在查询过程中(须通过唯一索引查询)给数据库表增加排他锁，我们可以认为获得排它锁的线程即可获得分布式锁，通过 connection.commit() 操作来释放锁。

会引入数据库单点、不可重入、无法保证一定使用行锁(部分情况下MySQL自动使用表锁而不是行锁)、排他锁长时间不提交导致占用数据库连接等问题。

**3. 数据库实现分布式锁总结**

优点：

- 直接借助数据库，容易理解。

缺点：

- 会引入更多的问题，使整个方案变得越来越复杂
- 操作数据库需要一定的开销，有一定的性能问题
- 使用数据库的行级锁并不一定靠谱，尤其是当我们的锁表并不大的时候