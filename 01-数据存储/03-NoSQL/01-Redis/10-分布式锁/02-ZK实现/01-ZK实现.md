==基于一个唯一的临时有序节点==

为什么使用 临时有序节点?

1. 避免羊群效应,  所有服务都去监听一个节点的，节点的释放也会通知所有的服务, 这些服务都会去竞争锁，Zookeeper 的压力会更大
2. 如果某个客户端创建临时顺序节点之后，不小心自己宕机了也没关系，zk感知到那个客户端宕机，会自动删除对应的临时顺序节点，相当于自动释放锁，或者是自动取消自己的排队。



判断是否获取锁的方式很简单，只需要判断有序节点中**序号最小的一个**

当释放锁的时候，只需将这个临时节点删除即可。

同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题

<img src="https://youpaiyun.zongqilive.cn/image/20210319100448.png" style="zoom:150%;" />



 

<img src="https://youpaiyun.zongqilive.cn/image/20210319100745.png" style="zoom:150%;" />



> 1，大家都是上来直接创建一个锁节点下的一个接一个的临时顺序节点
>
> 2，如果自己不是第一个节点，就对自己上一个节点加监听器
>
> 3，只要上一个节点释放锁，自己就排到前面去了，相当于是一个排队机制。
>
> 
>
> 







**Zookeeper实现分布式锁总结**

优点：

- 有效的解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题
- 实现较为简单

缺点：

- 性能上不如使用缓存实现的分布式锁，因为每次在创建锁和释放锁的过程中，都要动态创建、销毁临时节点来实现锁功能
- 需要对Zookeeper的原理有所了解





