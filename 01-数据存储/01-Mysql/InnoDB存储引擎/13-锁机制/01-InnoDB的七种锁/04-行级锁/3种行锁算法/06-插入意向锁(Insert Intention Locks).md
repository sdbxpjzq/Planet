### 插入意向锁(Insert Intention Locks)

1）插入意向锁是一种Gap锁，不是意向锁，在insert操作时产生。
（2）在多事务同时写入不同数据至同一索引间隙的时候，并不需要等待其他事务完成，不会发生锁等待。
（3）假设有一个记录索引包含键值4和7，不同的事务分别插入5和6，每个事务都会产生一个加在4-7之间的插入意向锁，获取在插入行上的排它锁，但是不会被互相锁住，因为数据行并不冲突。

（4）插入意向锁不会阻止任何锁，对于插入的记录会持有一个记录锁。
例如test表存在若干数据的数据，先开始一个事务A，插入一条n=5的数据；（图中步骤1）
此时如果开始一个事务B，执行查询 select * from test where n > 4 for update，事务B会申请Gap锁（4, ∞)，申请成功后，被事务A的x锁阻塞，直到x锁被释放。（图中步骤2）
可以看到图中步骤3的信息，在等待事务释放X锁

![](https://youpaiyun.zongqilive.cn/image/20200704103631.png)

![](https://youpaiyun.zongqilive.cn/image/20200704103638.png)

## 锁的兼容性

![](https://youpaiyun.zongqilive.cn/image/20200704103756.png)











插入意向锁，也是间隙锁的一种，在插入记录前，插入操作会先在所插入的索引范围内设置一个插入意向锁。插入意向锁和插入意向锁之间是兼容的，只要插入的键值不同，就不会相互阻塞。但是如果一个区间已经获取了间隙锁或临键锁，会阻塞插入意向锁的获取。



## 下边的实现有待商榷

举例：

假设 有表person，字段有id, name。隔离级别为 Repeatable read。

表内容：

| id   | name |
| ---- | ---- |
| 2    | Ray  |
| 7    | Mike |

- id 为主键或唯一键：

   

| 顺序 | 事务1                             | 事务2                                |
| ---- | --------------------------------- | ------------------------------------ |
| 1    | start transaction;                | start transaction;                   |
| 2    | Select * from person where id >5; |                                      |
| 3    |                                   | Insert into person values (6,’Rose’) |
| 4    |                                   | 阻塞                                 |