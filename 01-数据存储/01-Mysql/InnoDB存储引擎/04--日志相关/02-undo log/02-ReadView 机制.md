## ReadView 机制

当事务在开始执行的时候，会给每个事务生成一个 ReadView。这个 ReadView 会记录 4 个非常重要的属性

1. **creator_trx_id**: 当前事务的 id；
2. **m_ids**: 当前系统中所有的活跃事务的 id，活跃事务指的是当前系统中开启了事务，==但是还没有提交的事务==；
3. **min_trx_id**: 当前系统中，所有活跃事务中事务 id 最小的那个事务，也就是 m_id 数组中最小的事务 id；
4. **max_trx_id**: 当前系统中事务的 id 值最大的那个事务 id 值再加 1，也就是系统中下一个要生成的事务 id。



**ReadView 会根据这 4 个属性，再结合 undo log 版本链，来实现 MVCC 机制，决定让一个事务能读取到哪些数据，不能读取到哪些数据。**



## 读取规则

当一个事务读取某条数据时，就会按照如下规则来决定当前事务能读取到什么数据：

1. 如果当前数据的 trx_id `小于` min_trx_id，那么表示这条数据是在当前事务开启之前，其他的事务就已经将该条数据修改了并提交了事务(事务的 id 值是递增的)，所以当前事务能读取到。

2. 如果当前数据的 trx_id `大于等于` max_trx_id，那么表示在当前事务开启以后，过了一段时间，系统中有新的事务开启了，并且新的事务修改了这行数据的值并提交了事务，所以当前事务肯定是不能读取到的，因此这是后面的事务修改提交的数据。

3. 如果当前数据的 trx_id 处于 min_trx_id 和 max_trx_id 的`范围之间`，又需要分两种情况：

   （a）trx_id `在 m_ids 数组中`，那么当前事务不能读取到。为什么呢？trx_id 在 m_ids 数组中表示的是和当前事务在同一时刻开启的事务，修改了数据的值，并提交了事务，所以不能让当前事务读取到；

   （b) trx_id `不在 m_ids 数组中`，那么当前事务能读取到。trx_id 不在 m_ids 数组中表示的是在当前事务开启之前，其他事务将数据修改后就已经提交了事务，所以当前事务能读取到。

   

   **注意：如果 trx_id 等于当前事务的 id，那表示这条数据就是当前事务修改的，那当前事务肯定能读取到啊。**





参考: https://mp.weixin.qq.com/s/OsSQiCR6076bdoUjZKPXPg



## 生成时机

READ COMMITTED 隔离级别的事务在每次 查询开始时都会⽣成⼀个独⽴的ReadView。

REPEATABLE READ —— `只在第⼀次`读取数据时⽣成⼀个 ReadView，之后的查询就不会重复⽣成了。解决了 `不可重复读`   和`幻读`问题



参考: https://mp.weixin.qq.com/s/Mq9UcV94mTxi6J5SwthV7g



















