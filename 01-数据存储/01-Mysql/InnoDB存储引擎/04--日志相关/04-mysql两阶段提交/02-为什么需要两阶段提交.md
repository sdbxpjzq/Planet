这是为了让两份日志直接的逻辑一致

为什么要采用两阶段提交呢？

实际上，两阶段提交是分布式系统常用的机制。MySQL使用了两阶段提交后，也是为了保证事务的持久性。Redo log 和bingo 有一个共同的数据字段，叫 XID,崩溃恢复的时候，会按顺序扫描 redo log。

- 假设在写入binlog前系统崩溃，那么数据库恢复后顺序扫描 redo log，碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务，而且binlog也没写入，所以事务就直接回滚了。
- 假设在写入binlog之后，事务提交前数据库崩溃，那么数据库恢复后顺序扫描 redo log，碰到既有 prepare、又有 commit 的 redo log，就直接提交，保证数据不丢失。





### 先写 redo log 后写 binlog

  假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进行异常重启。由于我们前面说过，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 empname 的值是 “Java架构师养成记”。

  但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。

  然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 empname 的值就是 "测试一"，与原库的值不同。

### 先写binlog后写redo log

  如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 empname 的值是 “测试一”。但是 binlog 里面已经记录了“把 empname 从 测试一 改成 Java架构师养成记”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 “Java架构师养成记”，与原库的值不同。



> 可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。
>
> redo log 执行成功的话，当前数据库的值就会发生更新，但是 binlog 中记录的值是用来恢复数据库记录用的。