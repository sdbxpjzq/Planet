基于以上假设。可得：

事务A的视图数组[99,100]
事务B的视图数组是[99,100,101]
事务C的视图数组是[99,100,101,102]

![](https://youpaiyun.zongqilive.cn/image/20210319094323.png)

> 现在事务A要读数据了，它的视图数组[99,100]。当然了，读数据都是从当前版本读起的。所以，事务A查询语句的读数据流程是这样的：
>
> 找到(1,3)时，判断得row trx_id=101，比高水位还大，处红色区，不可见！
>
> 于是，找到上一历史版本，一看row trx_id 102，比高水位大，红色区，不可见!
>
> 再往前，终于找到（1,1)，row trx_id 90，比低水位小，处绿色区，可见!
>
> 执行下来，虽然期间这一行数据被后启动的事务们修改过了，但事务A不论在何时查询，看到这行数据的结果都一致，所以称之为一致性读。











![](https://youpaiyun.zongqilive.cn/image/20210319090116.png)

蓝色输出多少?

1 和 3 

> update 当前读,  数据行版本号为 当前的 事务版本号



这里，我们需要注意的是事务的启动时机。

- begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动,一致性视图是在执行第一个快照读语句时创建的。

- 如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令，一致性视图是在执行 start transaction with consistent snapshot 时创建的