## 事务的隔离级别

1. 读未提交 read uncommitted

2. 读已提交 read committed

3. 可重复读 repeatable read  -- mysql默认
4. 可串行化  serializable -- 对于同一行记录，“写”会加“写锁”，“读”会加“读锁”，当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

隔离程度 从上到下 , 越来越强



MySQL数据库中默认隔离级别为RR，但是实际情况是使用RC 和 RR隔离级别的都不少.



## 问题

1. `脏读` -- 当一个事务读取到另一个事务**`尚未提交`**的修改时, 产生脏读.
2. `不可重复读` -- 同一查询在同一事务中执行多次,由于其他提交事务所提交的**`修改`**或者**`删除`**, 每次返回不同的结果集, 此时发生非重复读.
3. `幻读`  -- 同一查询在同一事务中执行多次, 由于其他提交事务所做的`插入操作`,  每次返回不同的结果集, 此时发生 幻读. 

| 隔离级别                   | 脏读 | 不可重复读 | 幻读                 | 加锁读 |
| -------------------------- | ---- | ---------- | -------------------- | ------ |
| 读未提交(read uncommitted) | v    | v          | v                    | 不加锁 |
| 读已提交(read committed)   | x    | v          | v                    | 不加锁 |
| 可重复读(repeatable  read) | x    | x          | (mysql Innodb解决了) | 不加锁 |
| 可串行化                   | x    | x          | x                    | 加锁   |



## RC(读已提交) 与 RR(可重复读) 在锁方面的区别

1. RR 支持 gap lock(next-key lock)，而RC则没有gap lock。因为MySQL的RR需要gap lock来解决幻读问题。而RC隔离级别则是允许存在不可重复读和幻读的。所以RC的并发一般要好于RR
2. RC 隔离级别，通过 where 条件过滤之后，不符合条件的记录上的行锁，会释放掉(虽然这里破坏了“两阶段加锁原则”)；但是RR隔离级别，即使不符合where条件的记录，也不会释放行锁和gap lock；所以从锁方面来看，RC的并发应该要好于RR











