1. 服务之间调用少, 对数据实时要求 不高的情况下 可以使用



![](https://youpaiyun.zongqilive.cn/image/20200917194635.png)





其核心思想是将分布式事务拆分成本地事务进行处理。



方案通过在消费者额外新建事务消息表，消费者处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，提供者基于消息中间件消费事务消息表中的事务。

![](https://ae01.alicdn.com/kf/Ha3443447ef58468097503914994cb5b5Z.png)



**条件：** 

- **服务消费者需要创建一张消息表，用来记录消息状态。**
- **服务消费者和提供者需要支持幂等。**
- **需要补偿逻辑。**
- **每个节点上起定时线程，检查未处理完成或发出失败的消息，重新发出消息，即重试机制和幂等性机制。**



**处理流程：**

\1. 服务消费者把业务数据和消息一同提交，发起事务。

\2. 消息经过MQ发送到服务提供方，服务消费者等待处理结果。

\3. 服务提供方接收消息，完成业务逻辑并通知消费者已处理的消息。



容错处理情况如下：

- 当步骤1处理出错，事务回滚，相当于什么都没有发生。
- 当步骤2、3处理出错，由于消息保存在消费者表中，可以重新发送到MQ进行重试。
- 如果步骤3处理出错，且是业务上的失败，服务提供者发送消息通知消费者事务失败，且此时变为消费者发起回滚事务进行回滚逻辑。



**优点：**从应用设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于消息中间件，弱化了对 MQ 中间件特性的依赖。



**缺点：**与具体的业务场景绑定，耦合性强，不可公用。消息数据与业务数据同库，占用业务系统资源。业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限。