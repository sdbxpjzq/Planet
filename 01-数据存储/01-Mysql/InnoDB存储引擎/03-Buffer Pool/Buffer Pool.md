当需要访问某个 ⻚的数据时，就会把完整的⻚的数据全部加载到内存中，也就是说即 使我们只需要访问⼀个⻚的⼀条记录，那也需要先把整个⻚的数据加 载到内存中。将整个⻚加载到内存中后就可以进⾏读写访问了，在进 ⾏完读写访问之后并不着急把该⻚对应的内存空间释放掉，⽽是将其 缓存起来，这样将来有请求再次访问该⻚⾯时，就可以省去磁盘IO 的开销了。



## 内部组成

每个缓存⻚对应的控制信息占⽤的内存⼤⼩是相同的，

我们就把每个 ⻚对应的控制信息占⽤的⼀块内存称为⼀个控制块吧，控制块和缓存 ⻚是⼀⼀对应的，它们都被存放到 Buffer Pool 中，

其中控制块被存 放到 Buffer Pool 的前边，缓存⻚被存放到 Buffer Pool 后边，所以 整个Buffer Pool对应的内存空间看起来就是这样的：

![](https://youpaiyun.zongqilive.cn/image/20200902100514.png)



## free链表的管理

问题: 新页 该放到哪个缓存 ⻚的位置呢？或者说怎么区分Buffer Pool中哪些缓存⻚是空闲 的，哪些已经被使⽤了呢？



 把所有空闲的缓存⻚对应的控制块作为⼀个节点 放到⼀个链表中，这个链表也可以被称作free链表（或者说空闲链 表）。刚刚完成初始化的Buffer Pool中所有的缓存⻚都是空闲 的，所以每⼀个缓存⻚对应的控制块都会被加⼊到free链表中，

每当需要从磁盘中加载⼀个 ⻚到Buffer Pool中时，就从free链表中取⼀个空闲的缓存⻚，并 且把该缓存⻚对应的控制块的信息填上（就是该⻚所在的表空间、⻚ 号之类的信息），然后把该缓存⻚对应的free链表节点从链表中移 除，表示该缓存⻚已经被使⽤了～





## 缓存⻚的哈希处理

如何命中缓存页?



⽤表空间号 + ⻚号作为key，缓存⻚作为value创建 ⼀个哈希表，

在需要访问某个⻚的数据时，先从哈希表中根据表空间 号 + ⻚号看看有没有对应的缓存⻚，

如果有，直接使⽤该缓存⻚就 好，如果没有，那就从free链表中选⼀个空闲的缓存⻚，然后把磁 盘中对应的⻚加载到该缓存⻚的位置。



## flush链表的管理

修改了Buffer Pool中某个缓存⻚的数据，那它就和磁盘 上的⻚不⼀致了，这样的缓存⻚也被称为脏⻚.

脏页并不会⽴即把修改同步到磁盘上，⽽是在未来的某个时间点进⾏同步



如何区分哪些缓存页需要做磁盘同步呢?

创建⼀个存储脏⻚的链表，凡是修改过的缓存⻚对 应的控制块都会作为⼀个节点加⼊到⼀个链表中，因为这个链表节点 对应的缓存⻚都是需要被刷新到磁盘上的，所以也叫flush链表。

### 刷新脏⻚到磁盘

1. 从LRU链表的冷数据中刷新⼀部分⻚⾯到磁盘。

后台线程会定时从LRU链表尾部开始扫描⼀些⻚⾯，扫描的⻚ ⾯数量可以通过系统变量innodb_lru_scan_depth来指 定，如果从⾥边⼉发现脏⻚，会把它们刷新到磁盘。这种刷新 ⻚⾯的⽅式被称之为BUF_FLUSH_LRU。

2. 从flush链表中刷新⼀部分⻚⾯到磁盘。

   后台线程也会定时从flush链表中刷新⼀部分⻚⾯到磁盘，刷 新的速率取决于当时系统是不是很繁忙。这种刷新⻚⾯的⽅式 被称之为BUF_FLUSH_LIST。

3. 有时候后台线程刷新脏⻚的进度⽐较慢，导致⽤户线程在准备加载⼀ 个磁盘⻚到Buffer Pool时没有可⽤的缓存⻚，这时就会尝试看看 LRU链表尾部有没有可以直接释放掉的未修改⻚⾯，如果没有的话会 不得不将LRU链表尾部的⼀个脏⻚同步刷新到磁盘（和磁盘交互是很 慢的，这会降低处理⽤户请求的速度）。这种刷新单个⻚⾯到磁盘中 的刷新⽅式被称之为BUF_FLUSH_SINGLE_PAGE。





## 缓存失效策略

LRU链表按照⼀定⽐例分成两截，分别是：

1. ⼀部分存储使⽤频率⾮常⾼的缓存⻚，所以这⼀部分链表也叫 做热数据，或者称young区域。
2. 另⼀部分存储使⽤频率不是很⾼的缓存⻚，所以这⼀部分链表 也叫做冷数据，或者称old区域。

我们可 以通过查看系统变量`innodb_old_blocks_pct`的值来确定old区 域在LRU链表中所占的⽐例，

![](https://youpaiyun.zongqilive.cn/image/20200902104921.png)

#### 解决:   从old区域移动到young区域的头部

否则将它移动到young区 域的头部。是由系统变量`innodb_old_blocks_time`这个间隔时间控制的

对于LRU链表的old区域的某个⻚ 来说，如果第⼀次和最后⼀次访问该⻚⾯的时间间隔⼩于 这个时间间隔, 那么该⻚是不会被加⼊到young区域的



还有其他的优化

⽐如只有被访问的缓存⻚位于young区域的1/4的后边，才 会被移动到LRU链表头部，这样就可以降低调整LRU链表的频率，从 ⽽提升性能（也就是说如果某个缓存⻚对应的节点在young区域的 1/4中，再次访问该缓存⻚时也不会将其移动到LRU链表头部）







## 多个Buffer Pool实例

```
[server] 
innodb_buffer_pool_instances = 2
```

当innodb_buffer_pool_size的值⼩于1G的时候设置多个实例 是⽆效的，InnoDB会默认把innodb_buffer_pool_instances 的值 修改为1。

⽽我们⿎励在Buffer Pool⼤⼩或等于1G的时候设置多 个Buffer Pool实例。



⾃MySQL 5.7.5版本之后，可以在服务器运⾏过程中调 整Buffer Pool⼤⼩。每个Buffer Pool实例由若⼲ 个chunk组成，每个chunk的⼤⼩可以在服务器启动时通过启 动参数调整。`innodb_buffer_pool_chunk_size`

![](https://youpaiyun.zongqilive.cn/image/20200902145723.png)





## 令查看Buffer Pool的状态信息

```
SHOW ENGINE INNODB STATUS\G
```





















































































