HashMap的底层实现原理? 以JDK7为例说明:

`HashMap map = new HashMap()`

在实例化以后, 底层创建了长度是`16`的一维数组`Entry [] table`.

... 可能执行过多次put...

`map,put(key1, value1)`

首先调用`key1`所在类的`hashCode()`计算`key1`的哈希值,  此哈希值经过某种算法计算以后, 得到`Entry`数组中的存放位置:

- 若此位置上的数据为`空`, 此时`key1-value1`添加成功 -- **情况1**
- 若此位置上的数据为`不空`,(意味着此位置上存在一个或多个数据以链表形式存在), 比较`key1`和已经存的数据的 哈希值:
  - 若`key1`的哈希值与已存在数据的哈希值 都`不相同`, 此时`key1-value1`添加成功 -- **情况2**
  - 若`key1`的哈希值与已存的某一个数据(`key2-value2`)的哈希值 `相同`, 继续比较`key1`所在类的`equals(key2)`
    - `equals()`返回`false`,  此时`key1-value1`添加成功 -- **情况3**
    - `equals()` 返回`true`,  使用`value1` 替换`value2`



关于`情况2`和`情况3`:

此时的`key1-value1`和原来的数据以链表的方式存储.

在不断添加的过程中, 会涉及到扩容问题, 

默认的扩容: 扩容为原来容量的`2倍`, 并将原有的数据复制过来

## jdk8和jdk7在实现方面的不同

1. `new HashMap()`: 底层没有创建一个长度为`16`的数组

2. jdk8底层的数组是 `Node[]` , 而非`Entry []`

3. 首次调用`put()`时, 底层创建长度为`16`的数组

4. 形成链表结构时, 新添加的`key-value`在链表的尾部(7上, 8下)

5. jdk7底层结构只有:`数组+链表`.  jdk8中底层结构: `数组+链表+红黑树`

   当数组的某一个索引位置上的元素以`链表`方式存储的数据个数 > `8` 且 当前数组的长度 >` 64` 时,  此索引位置上的所有数据 改为 `红黑树`存储



![](https://pic3.superbed.cn/item/5dff115d76085c328930b237.jpg)





![](https://pic3.superbed.cn/item/5dff11b576085c328930e504.jpg)























