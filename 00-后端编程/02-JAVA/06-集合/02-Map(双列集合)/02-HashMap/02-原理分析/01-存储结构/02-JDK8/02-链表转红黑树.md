## 链表 转 红黑树

当链表大于8并且容量超过64时。链表就会变成红黑树。

1. 同一链表的长度  `>=8[TREEIFY_THRESHOLD]`
2. 且容量数组长度 >= `MIN_TREEIFY_CAPACITY=64`, 这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化



```
// 最小树形化容量阈值：即 当哈希表中的容量 > 该值时，才允许树形化链表 （即 将链表 转换成红黑树）
// 否则，若桶内元素太多时，则直接扩容，而不是树形化
// 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD
static final int MIN_TREEIFY_CAPACITY = 64;
```



==当一个链表中的节点数 >=8 , 但此时 capacity没有达到64. 那么会先扩容解决==



## 注意

红黑树的`root`节点`不一定`跟`table[i]`也就是链表的头节点是同一个哦

