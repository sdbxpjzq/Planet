## 扩容后元素的位置

两种情况

1. 要么是在原位置

2. 要么`原索引+oldCap`

   > 也就是说如果上次容量是16，下次扩容后变成了16+16, 也就是说如果上次容量是16，
   >
   > 如果一个元素在下标为7的位置，下次扩容时，要不还在7的位置，要不在7+16的位置。

## 图解分析

n为table的长度，

图（a）表示扩容前的key1和key2两种key确定索引位置的示例，

图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。

<img src="https://youpaiyun.zongqilive.cn/image/20210205150755.png" style="zoom:150%;" />

元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：

![](https://youpaiyun.zongqilive.cn/image/20210205150845.png)

所以, 我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成`原索引+oldCap`

这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点







