## G1(Garbage-First) (-XX:+UseG1GC)

- 主要针对配备多颗处理器及大容量内存的机 器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征
- 是JDK9+的默认垃圾收集器
- 年轻代 或是老年代，回收算法主要用的是`复制算法`
- G1保留了年轻代和老年代的概念，但不再是物理隔阂了，它们都是(可以不连续)Region的集 合。
- 一个Region可能之前是年轻代，如果Region进行了垃圾回收，之后可能又会变成老年代，也就是 说Region的区域功能可能会动态变化。

![](https://youpaiyun.zongqilive.cn/image/20200609155614.png)

- G1将Java堆划分为多个大小相等的独立区域(Region)，JVM最多可以有2048个Region。 
  - 一般Region大小等于堆大小除以2048，比如堆大小为4096M，则Region大小为2M，当然也可以 用参数`-XX:G1HeapRegionSize`手动指定Region大小，但是推荐默认的计算方式。

- 默认年轻代对堆内存的占比是5%，如果堆大小为4096M，那么年轻代占据200MB左右的内存， 对应大概是100个Region，
  - 可以通过`-XX:G1NewSizePercent`设置新生代初始占比，在系统运行中，JVM会不停的给年轻代增加更多的Region，但是最多新生代的占比不会超过60%，可以 通过`-XX:G1MaxNewSizePercent`调整。
  - 年轻代中的Eden和Survivor对应的region也跟之前 一样，默认8:1:1，假设年轻代现在有1000个region，eden区对应800个，s0对应100个，s1对应 100个。

- `Humongous区`
  - 专门分配大对象的Region, 而不是让大对象直接进入老年代的 Region中, 一般超过0.5个Region, 就放到H区
  - 在G1中，大对象的判定规则就是一个大对象超过了一个Region大小的50%，比如按 照上面算的，每个Region是2M，只要一个大对象超过了1M，就会被放入Humongous中，而且 一个大对象如果太大，可能会横跨多个Region来存放。
  - Humongous区专门存放短期巨型对象，不用直接进老年代，可以节约老年代的空间，避免因为老 年代空间不够的GC开销。
- Full GC的时候除了收集年轻代和老年代之外，也会将Humongous区一并回收。



## 设置H的原因:

堆中的大对象, 默认直接会被分配到老年代, 但是如果它是一个短期存在的大对象, 就会对垃圾收集器造成负面影响,

为了解决这个问题, G1划分了一个Humongous区, 专门来存放大对象, 如果一个H区放不一个大对象, 那么G1会寻找连续的H区来存储.

为了能找到连续的H区, 有个时候不得不启动Full GC,

多数情况下都把H区作为老年代的一部分来看待















































