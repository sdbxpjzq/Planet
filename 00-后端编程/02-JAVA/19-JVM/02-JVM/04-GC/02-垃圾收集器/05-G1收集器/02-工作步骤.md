## 工作4个步骤

1. 初始标记(initial mark，STW)

   ==触发STW==

   暂停所有的其他线程，并记录下gc roots直接能引用的对象，速度很快 ;

2. 并发标记(Concurrent Marking)
   同CMS的并发标记 

3. 重新标记(Remark，STW)

   ==触发STW==

   同CMS的重新标记 

4. 筛选回收(Cleanup，STW)
   ==触发STW==

   - 筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间
     (可以用JVM参数 `-XX:MaxGCPauseMillis`指定)来制 定回收计划，

   - 比如说老年代此时有1000个Region都满了，但是因为根据预期停顿时间，本 次垃圾回收可能只能停顿200毫秒，那么通过之前回收成本计算得知，可能回收其中800个 Region刚好需要200ms，那么就只会回收800个Region，尽量把GC导致的停顿时间控制在 我们指定的范围内。这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一 部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。



![](https://youpaiyun.zongqilive.cn/image/20200425153840.png)

G1收集器在后台维护了一个`优先列表`，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字Garbage-First的由来)，

比如一个Region花200ms能回收10M垃 圾，另外一个Region花50ms能回收20M垃圾，在回收时间有限情况下，G1当然会优先选择后面 这个Region回收。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集 器在有限时间内可以尽可能高的收集效率。



