![](https://youpaiyun.zongqilive.cn/image/20210115163236.png)





## 对象分配

- 优先分配到Eden

- 大对象直接分配到老年代

  - 大对象就是需要大量连续内存空间的对象(比如:字符串、数组)。JVM参数 - XX:PretenureSizeThreshold 可以设置大对象的大小，如果对象超过设置大小 会直接进入老年代，不会进入年轻代，这个参数只在 Serial 和ParNew两个收集 器下有效。
  - 为了避免为大对象分配内存时的复制操作而降低效率。

- 长期存活的对象将进入老年代

  - 对象 在 Survivor 中每熬过一次 MinorGC，年龄就增加1岁，当它的年龄增加到一定 程度(默认为15岁)，就会被晋升到老年代中。
  - 可以通过参数来设置。`-XX:MaxTenuringThreshold`

- 对象年龄判断
  
  - 如果S区中相同年龄的所有对象的大小总和  大于  S区空间的一半,  则年龄大于或等于该年龄的对象可以直接进入老年代, 无需等到 年龄最大值
  - 判断机制一般是在minor gc之后触发 的。
  
- Minor gc后存活的对象Survivor区放不下

  - 会把存活的对象部分挪到老年代，部分可能还会放在Survivor区

- 空间分配担保
  
  - 年轻代每次minor gc之前JVM都会计算下老年代剩余可用空间, 如果这个可用空间小于年轻代里现有的所有对象大小之和(包括垃圾对象), 就会看一个“-XX:-HandlePromotionFailure”(jdk1.8默认就设置了)的参数是 否设置了 如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每一次minor gc后进入老年代的对象的平均大小。 如果上一步结果是小于或者之前说的参数没有设置，那么就会触发一次Full gc，对老年代和年轻代一起回收一次垃圾，如果回收完还是没有足够空间存放 新的对象就会发生"OOM"
  
    当然，如果minor gc之后剩余存活的需要挪动到老年代的对象大小还是大于老 年代可用空间，那么也会触发full gc，full gc完之后如果还是没用空间放minor gc之后的存活对象，则也会发生“OOM”
  
  - -XX:handlePromotionFailure





![](https://youpaiyun.zongqilive.cn/image/20210116120725.png)



 



## 对象分配一般过程

1. `new`的对象先放到`Eden区`,此区域大小有限制
2. 当`Eden区`的空间填满时, 将对`Eden区`进行`Minor GC`
3. 然后将`Eden区`剩余的对象移动到`幸存者0区`
4. 再次触发GC, 会对`Eden区`和`幸存者0区`进行扫描, 此次幸存下的对象移动到`幸存者1区`
5. 如果再次GC, 此时重新放回`幸存者0区`, 接着再去`幸存者1区`
6. 啥时候能去养老区?可以设置次数. 默认是`15`次. 通过`-XXMaxTenuringThreshold=<N>`进行设置
7. 当养老区内存不足时, 再次触发`major GC`
8. 若养老区执行了`Major GC`之后发现依然无法进行对象的保存, 就会产生`OOM`异常(实际是个错误)

 

### 注意点

1. 针对幸存者s0,s1总结: `复制之后有交换, 谁空谁是 to`





![](https://youpaiyun.zongqilive.cn/image/20200522164037.png)



























