## 程序计数器

其实你可以把它看作是当前线程执行的字节码的行号指示器，在 Jvm 工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环，跳转，异常处理，线程的恢复等工作都需要依赖程序计数器去完成。它就好像是一个路口的红绿灯一样。

`特点`：1、占用很小的内存 2、各线程私有







用于记录Java程序在当前线程运行的`下一条指令的地址`（下一行要执行代码的行号），执行引擎可以由此读取下一条指令执行。

程序计数器占用的内存空间较小，是当前线程所执行的字节码行号指示器，通过改变这个计数器的值来选取下一条需要执行的字节码指令。多个线程之间的程序计数器相互独立，为了保证每个线程恢复后都可以找到具体的执行位置。

![](https://youpaiyun.zongqilive.cn/image/20200319162012.png)

注意：

- 每个线程都有独立的程序计数器并线程私有，生命周期与线程一致！
- 如果当前执行的是Native方法，则程序寄存器不起作用，值始终为`undefined`
  字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。
  它是唯一一 个在Java虚拟机规范中没有规定任何OutOtMemoryError情况的区域。

- 如果当前执行的是Native方法，则程序寄存器不起作用，值始终为`undefined`
  字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。
  它是唯一一 个在Java虚拟机规范中没有规定任何OutOtMemoryError情况的区域。

每个线程都有一个程序计数器器, 是线程私有的, 是就是一个指针, 指向方法区的中的方法字节码(用来存储指向吓一跳指令的地址, 也即将要执行的指令代码), 由执行引擎读取下一条指令, 是一个非常小的内存空间

这块内存区域很小, **它是当前线程所执行的字节码的型号指示器**, 字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令.

如果执行的是一个Native方法, 那这个计数器是空的.

用以完成分支, 循环, 跳转, 异常处理, 线程恢复等基础功能, 不会发生内存溢出(OutOfMemory=OOM)错误

> 注意：native方法不归java管，所以计数器是空的



![](https://youpaiyun.zongqilive.cn/image/20200319163032.png)

![](https://youpaiyun.zongqilive.cn/image/20200319163052.png)



## **问题：为什么要使用程序计数器来记录行号？**

因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。

## **问题2：程序计数器为什么要设定为线程私有？**

所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。

























