## 线程如何回收

#### 未调用shutdown() ，RUNNING状态下全部任务执行完成的场景

如果当前线程数大于核心线程数，变量timed为true, 否则为false（上面说了，这里只讨论allowCoreThreadTimeOut为false的情况）。很明显，现在讨论的是timed为true的情况。keepAliveTime一般不设置，默认值为0，所以基本上可以认为是不阻塞，马上返回取任务的结果。



在线程超时等待唤醒之后，发现取不出任务，timeOut变为true，进入下一次循环。

step2. 来到条件1的判断，线程池一直RUNNING, 不进入代码块。

step3. 来到条件2的判断，这时任务队列为空，条件成立，CAS减少线程数，若成功，返回null，否则，重复step1。

这里要注意，有可能多条线程同时通过条件2的判断，那会不会减少后线程的数量反而比预想的核心线程数少呢？

比如当前线程数已经只有5条了，此时有两条线程同时唤醒，通过条件2的判断，同时减少数量，那剩下的线程数反而只有3条，和预期不一致。

实际上是不会的。为了防止这种情况，compareAndDecrementWorkerCount(c) 用的是CAS方法，如果CAS失败就continue，进入下一轮循环，重新判断。

像上述例子，其中一条线程会CAS失败，然后重新进入循环，发现工作线程数已经只有4了，timed为false, 这条线程就不会被销毁，可以一直阻塞了（workQueue.take())。

这一点我思考了很久才得出答案，一直在想没有加锁的情况下是怎么保证一定能不多不少回收到核心线程数的呢。原来是CAS的奥妙。

从这里也可以看出，虽然有核心线程数，但线程并没有区分是核心还是非核心，并不是先创建的就是核心，超过核心线程数后创建的就是非核心，最终保留哪些线程，完全随机。

![](https://youpaiyun.zongqilive.cn/image/20210314102135.png)

