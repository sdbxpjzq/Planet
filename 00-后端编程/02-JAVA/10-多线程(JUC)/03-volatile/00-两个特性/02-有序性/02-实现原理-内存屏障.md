插入一个内存屏障, 相当于告诉CPU和编译器

>  先于这个命令的必须先执行, 后于这个命令的必须后执行.

内存屏障另一个作用是

> 强制更新一次不同CPU的缓存

例如

```
一个写屏障会把这个屏障前写入的数据刷新到缓存,
这样任何试图读取该数据的线程将得到最新值,
而不用考虑到底是被哪个CPU核心或者哪颗CPU执行的.
```



**volatile是基于内存屏障实现的**

```
如果一个变量是volatile修饰的,
JMM会在写入这个变量之后插进一个写屏障指令,
并在读这个字段之前插入一个读屏障指令,

这意味着：
一个线程写入变量X后,任何线程访问该变量都会拿到最新值.
在写入变量X之前的写入操作,
其更新的数据对于其他线程也是可见的.
因为内存屏障会刷出cache中的所有先前的写入.
```

**synchronized底层也是通过释放屏障和获取屏障的配对使用保障有序性, 加载屏障和存储屏障的配对使用保障可见性**

```
通过synchronized关键字包住的代码区域,
当线程进入到该区域读取变量信息时,保证读到的是最新的值
```



内存屏障是啥啊？

内存屏障，也称`内存栅栏`，内存栅障，屏障指令等， 是一类同步屏障指令，是 CPU 或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。也是一个让CPU 处理单元中的内存状态对其它处理单元可见的一项技术。

**CPU 使用了很多优化，使用缓存、指令重排等，其最终的目的都是为了性能**，也就是说，当一个程序执行时，只要最终的结果是一样的，指令是否被重排并不重要。所以指令的执行时序并不是顺序执行的，而是乱序执行的，这就会带来很多问题，这也促使着内存屏障的出现。

语义上，内存屏障之前的所有写操作都要写入内存；内存屏障之后的读操作都可以获得同步屏障之前的写操作的结果。因此，对于敏感的程序块，写操作之后、读操作之前可以插入内存屏障。

内存屏障的开销非常轻量级，但是再小也是有开销的，LazySet 的作用正是如此，它会以普通变量的形式来读写变量。





为了实现volatile可见性和happen-befor的语义。在JVM底层volatile是采用`内存屏障`来实现的

## 内存屏障会提供3个功能：

**I. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；**

**II. 它会强制将对缓存的修改操作立即写入主存；**

**III. 如果是写操作，它会导致其他CPU中对应的缓存行无效。**





## 内存屏障

内存屏障主要有以下分类:

![](https://youpaiyun.zongqilive.cn/image/20200712152137.png)

#### JMM保守策略

1. 在每个volatile`写操作`的前面插入一个`StoreStore屏障`

   ```
   StoreStore 屏障
   执行顺序：Store1—>StoreStore—>Store2
   确保Store2以及后续Store指令执行前，Store1操作的数据对其它处理器可见。
   ```

   

2. 在每个volatile`写操作`的`后面`插入一个`StoreLoad屏障`

   ```
   StoreLoad 屏障
   执行顺序: Store1—> StoreLoad—>Load2
   确保Load2和后续的Load指令读取之前，Store1的数据对其他处理器是可见的。
   ```

   

3. 在每个volatile`读操作`的`前面`插入一个`LoadLoad屏障`

```
LoadLoad 屏障
执行顺序：Load1—>Loadload—>Load2
确保Load2及后续Load指令加载数据之前能访问到Load1加载的数据。
```



4. 在每个volatile`读操作`的`后面`插入一个`LoadStore屏障`

   ```
   LoadStore 屏障
   执行顺序：Load1—>LoadStore—>Store2
   确保Store2和后续Store指令执行前，可以访问到Load1加载的数据。
   ```

通过一个实例来说明一下JVM中是如何插入内存屏障的：

```java
public class MemoryBarrier {
    int a, b;
    volatile int v, u;

    void f() {
        int i, j;

        i = a;
        j = b;
        i = v;
        //LoadLoad
        j = u;
        //LoadStore
        a = i;
        b = j;
        //StoreStore
        v = i;
        //StoreStore
        u = j;
        //StoreLoad
        i = u;
        //LoadLoad
        //LoadStore
        j = b;
        a = i;
    }
}
```





![](https://youpaiyun.zongqilive.cn/image/20200712152344.png)

![](https://youpaiyun.zongqilive.cn/image/20200712152419.png)