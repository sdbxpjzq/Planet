## 锁撤销

- 如果对象锁已经被其他线程占用，则会替换失败，开始进行偏向锁撤销，这也是偏向锁的特点，一旦出现线程竞争，就会撤销偏向锁；

- 偏向锁的撤销需要等待全局安全点（safe point，代表了一个状态，在该状态下所有线程都是暂停的）,暂停持有偏向锁的线程，检查持有偏向锁的线程状态（遍历当前JVM的所有线程，如果能找到，则说明偏向的线程还存活），如果线程还存活，则检查线程是否在执行同步代码块中的代码，如果是，则升级为轻量级锁，进行CAS竞争锁；

  >注：每次进入同步块（即执行monitorenter）的时候都会以从高往低的顺序在栈中找到第一个可用的Lock Record，并设置偏向线程ID；每次解锁（即执行monitorexit）的时候都会从最低的一个Lock Record移除。所以如果能找到对应的Lock Record说明偏向的线程还在执行同步代码块中的代码。

- 如果持有偏向锁的线程未存活，或者持有偏向锁的线程未在执行同步代码块中的代码，则进行校验是否允许重偏向，如果不允许重偏向，则撤销偏向锁，将Mark Word设置为无锁状态（未锁定不可偏向状态），然后升级为轻量级锁，进行CAS竞争锁；

- 如果允许重偏向，设置为匿名偏向锁状态,CAS将偏向锁重新指向新线程ID；

- 唤醒暂停的线程，从安全点继续执行代码。



总结----偏向撤销的结果分为几种情况:

1. 持有锁线程存活，直接升级为轻量级锁

2. 持有锁线程未存活，

3. 1. 锁对象不可偏向，将其置为无锁（未偏向不可偏向状态），然后升级为轻量锁
   2. 锁对象可偏向，将其置为匿名偏向锁（未偏向可偏向状态），CAS竞争偏向锁（在锁对象头的mark word和线程栈帧锁记录写入线程ID）



撤销偏向锁的时候会导致进入安全点，安全点会导致stw，导致性能下降，这种情况下应当禁用，高并发的应用会禁用掉偏向锁。

