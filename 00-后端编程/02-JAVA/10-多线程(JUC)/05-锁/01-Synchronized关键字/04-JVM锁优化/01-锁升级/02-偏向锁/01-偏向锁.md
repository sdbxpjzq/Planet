## 偏向锁

目的：锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，所以引入偏向锁让线程获得锁的代价更低。

一旦有不同的线程获取或竞争锁对象，偏向锁就升级为轻量级锁。

==偏向锁修改的是 线程ID==

偏向锁假定将来只有第一个申请锁的线程会使用锁（之后不会再有任何线程再来申请锁）, 只执行一次CAS操作

大多数情况下，==总是只有ThreadA去访问(同一线)，不存在竞争,== 为了让线程获得锁的代价更低引入了偏向锁。



当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解释，只需要简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果是，则直接获得锁，执行同步块；如果不是，则使用CAS操作更改线程ID，更改成功获得锁，更改失败开始`撤销偏向锁`。



## 偏向锁延迟与关闭

**偏向锁延迟4s开启**, 这到底是为什么呢，想象一下JVM刚启动的时候，一定是有很多的线程在运行，操作系统也是知道的，所以明明知道有高并发的场景，所以就延迟了4s。

偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动4秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟`-XX：BiasedLockingStartupDelay = 0`。如果你确定自己应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁`-XX:-UseBiasedLocking=false`，那么默认会进入轻量级锁状态。

![](https://youpaiyun.zongqilive.cn/image/20200710154210.png)