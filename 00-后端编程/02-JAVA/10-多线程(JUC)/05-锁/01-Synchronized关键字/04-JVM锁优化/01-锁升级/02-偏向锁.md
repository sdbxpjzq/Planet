## 偏向锁

目的：大多数情况下锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，所以引入偏向锁让线程获得锁的代价更低。

偏向锁认为环境中不存在竞争情况，锁只被一个线程持有，**一旦有不同的线程获取或竞争锁对象，偏向锁就升级为轻量级锁。**

偏向锁在无多线程竞争的情况下可以减少不必须要的轻量级锁执行路径。



==偏向锁修改的是 线程ID==

偏向锁假定将来只有第一个申请锁的线程会使用锁（之后不会再有任何线程再来申请锁）, 只执行一次CAS操作

大多数情况下，==总是只有ThreadA去访问(同一线)，不存在竞争,== 为了让线程获得锁的代价更低引入了偏向锁。



当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解释，只需要简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果是，则直接获得锁，执行同步块；如果不是，则使用CAS操作更改线程ID，更改成功获得锁，更改失败开始`撤销偏向锁`。



## 偏向锁重入

以后该线程进入同步块时，不需要CAS进行加锁，只会往当前线程的栈中添加一条Displaced Mark Word为空的Lock Record中，用来统计重入的次数（如图为当对象所处于偏向锁时，当前线程重入3次，线程栈帧中Lock Record记录）。

![](https://youpaiyun.zongqilive.cn/image/20200711170825.png)

## 锁释放

退出同步块释放偏向锁时，则依次删除对应Lock Record，==但是不会修改对象头中的Thread Id；==

> 注：偏向锁撤销是指在获取偏向锁的过程中因不满足条件导致要将锁对象改为非偏向锁状态，而偏向锁释放是指退出同步块时的过程。





## 锁撤销

- 如果对象锁已经被其他线程占用，则会替换失败，开始进行偏向锁撤销，这也是偏向锁的特点，一旦出现线程竞争，就会撤销偏向锁；

- 偏向锁的撤销需要等待全局安全点（safe point，代表了一个状态，在该状态下所有线程都是暂停的）,暂停持有偏向锁的线程，检查持有偏向锁的线程状态（遍历当前JVM的所有线程，如果能找到，则说明偏向的线程还存活），如果线程还存活，则检查线程是否在执行同步代码块中的代码，如果是，则升级为轻量级锁，进行CAS竞争锁；

  >注：每次进入同步块（即执行monitorenter）的时候都会以从高往低的顺序在栈中找到第一个可用的Lock Record，并设置偏向线程ID；每次解锁（即执行monitorexit）的时候都会从最低的一个Lock Record移除。所以如果能找到对应的Lock Record说明偏向的线程还在执行同步代码块中的代码。

- 如果持有偏向锁的线程未存活，或者持有偏向锁的线程未在执行同步代码块中的代码，则进行校验是否允许重偏向，如果不允许重偏向，则撤销偏向锁，将Mark Word设置为无锁状态（未锁定不可偏向状态），然后升级为轻量级锁，进行CAS竞争锁；
- 如果允许重偏向，设置为匿名偏向锁状态,CAS将偏向锁重新指向新线程ID；
- 唤醒暂停的线程，从安全点继续执行代码。



总结----偏向撤销的结果分为几种情况:

1. 持有锁线程存活，直接升级为轻量级锁

2. 持有锁线程未存活，

3. 1. 锁对象不可偏向，将其置为无锁（未偏向不可偏向状态），然后升级为轻量锁
   2. 锁对象可偏向，将其置为匿名偏向锁（未偏向可偏向状态），CAS竞争偏向锁（在锁对象头的mark word和线程栈帧锁记录写入线程ID）



撤销偏向锁的时候会导致进入安全点，安全点会导致stw，导致性能下降，这种情况下应当禁用，高并发的应用会禁用掉偏向锁。



## 延伸---- 批量重偏向与批量撤销

#### 渊源

从偏向锁的加锁解锁过程中可看出，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时，再将偏向锁撤销为无锁状态或升级为轻量级，会消耗一定的性能，所以在多线程竞争频繁的情况下，偏向锁不仅不能提高性能，还会导致性能下降。
于是，就有了批量重偏向与批量撤销的机制。



#### 解决场景:

批量重偏向（bulk rebias）机制是为了解决：一个线程创建了大量对象并执行了初始的同步操作，后来另一个线程也来将这些对象作为锁对象进行操作，这样会导致大量的偏向锁撤销操作。
批量撤销（bulk revoke）机制是为了解决：在明显多线程竞争剧烈的场景下使用偏向锁是不合适的。





#### 原理

以class为单位，为每个class维护一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器+1，当这个值达到重偏向阈值（默认20）时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。
每个class对象会有一个对应的epoch字段，每个处于偏向锁状态对象的Mark Word中也有该字段，其初始值为创建该对象时class中的epoch的值。
每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的栈，找到该class所有正处于加锁状态的偏向锁，将其epoch字段改为新值。下次获得锁时，发现当前对象的epoch值和class的epoch不相等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其Mark Word的Thread Id 改成当前线程Id。
当达到重偏向阈值后，假设该class计数器继续增长，当其达到批量撤销的阈值后（默认40），JVM就认为该class的使用场景存在多线程竞争，会标记该class为不可偏向，之后，对于该class的锁，直接走轻量级锁的逻辑。





## 被hash的对象不可用作偏向锁



如果一个对象处于偏向状态(匿名偏向、可重偏向、已偏向)，那么该对象的MarkWord中原本预存hashcode的bit位却用来存放或者将要存放所偏向线程的thread ID了，此时该对象如果进行hash运算所生成的hash值无处存放，这就是导致为什么偏向锁对象不能进行hash运算。-----个人理解，有误请指正



```java

/**
 * 对象执行hashcode()方法不可用作偏向锁
 */
// -XX:BiasedLockingStartupDelay=0  jvm关闭偏向锁延迟
public class JOLExample3 {
    public static void main(String[] args) throws InterruptedException {
         // Thread.sleep(5000); // 超过4s延迟，对象开启的是偏向锁
         A a = new A();
         a.hashCode();
        System.out.println("before lock");
        System.out.println(ClassLayout.parseInstance(a).toPrintable());
        synchronized (a) {
            System.out.println("locking");
            System.out.println(ClassLayout.parseInstance(a).toPrintable());
        }
    }
}
```

![](https://youpaiyun.zongqilive.cn/image/20200711192949.png)



## 偏向锁延迟与关闭

**偏向锁延迟4s开启**, 这到底是为什么呢，想象一下JVM刚启动的时候，一定是有很多的线程在运行，操作系统也是知道的，所以明明知道有高并发的场景，所以就延迟了4s。



偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动4秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟`-XX：BiasedLockingStartupDelay = 0`。如果你确定自己应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁`-XX:-UseBiasedLocking=false`，那么默认会进入轻量级锁状态。





![](https://youpaiyun.zongqilive.cn/image/20200710154210.png)