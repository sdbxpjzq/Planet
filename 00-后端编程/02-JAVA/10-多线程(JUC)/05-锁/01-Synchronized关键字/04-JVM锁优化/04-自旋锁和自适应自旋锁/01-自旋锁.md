大多数情况下，线程持有锁的时间都不会太长，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。

## 自旋锁

当锁被占用时，当前想要获取锁的线程不会被立即挂起，而是做几个空循环，看持有锁的线程是否会很快释放锁。
在经过若干次循环后，如果得到锁，就顺利进入临界区；如果还不能获得锁，那就会将线程在操作系统层面挂起

好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。

## 自旋锁和阻塞最大的区别

主要区别：是不是放弃处理器的执行时间。

阻塞放弃了CPU时间，进入了等待区，等待被唤醒。响应慢。

自旋锁一直占用CPU时间，时刻检查共享资源是否可以被访问，所以响应速度更快。



## 缺点

如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好。

但是如果持有锁的线程占用锁时间较长，等待锁的线程自旋一定次数后还是拿不到锁而被阻塞，那么自旋就白白浪费了CPU的资源。
所以自旋的次数直接决定了自旋锁的性能。==JDK自旋的默认次数为10次==，可以通过参数`-XX:PreBlockSpin`来调整。





